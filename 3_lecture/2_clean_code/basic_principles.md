# Базовые принципы написания хороших функций и методов

## Компактность

Функции должны быть короткими. Идеальные функции - это функции на 2-4 строчки кода. Они делают строго то, для чего они предназначены. Ни больше, ни меньше.
Не всегда получается создавать такие функции, для меня функция является адекватной, если в ней 20-40 строчек кода.

В чем минус больших функций на 50, 100, 200 строчек кода? Когнитивная нагрузка на мозг. Очень сложно читать, очень сложно понимать, что и где было реализовано в этой функции.

## Правило одной операции

Функция должна выполнять только одну операцию. Она должны выполнять ее хорошо и ничего другого она делать не должна.
Функцию, выполняющую только одну операцию, невозможно осмысленно разделить на разные логические секции.

## Один уровень абстракции на функцию

Внутри функции должны быть операции, которые находятся на одном уровне абстракции, пример:

```python
def collect_user_info():
    users = fetch_users_from_file("users.txt")
    info = calculate_users_info(users)
    save_info_to_file("users_info.txt", info)
```

Тут вы можете возразить, что функция делает много вещей - считывает данные с файла, рассчитывает информацию, сохраняет в файл.
Но само название функции достаточно абстрактное, то есть оно подразумевает, что действия внутри должны привести к тому, что мы соберем пользовательскую информацию.
Какими путями мы будем это делать функция не конкретезирует.
В тоже самое время у нас внутри есть три функции, которые находятся на более низком уровне абстракции:
    - отбор данных из файла
    - рассчет информации
    - сохранение информации

Они на одном уровне. Внутри они уже углубляются в детали.

## Чтение кода сверху вниз: правило понижения. 

Код дожен читаться как рассказ - сверху вниз. 
За каждой функций должны следовать функции следующего уровня абстракции. Позволяет читать код последовательно, спускаясь по уровням абстракции.
В питоне это применимо только к методам классов. 

На примере выше:

```python
def collect_user_info():
    users = fetch_users_from_file("users.txt")
    info = calculate_users_info(users)
    save_info_to_file("users_info.txt", info)

def fetch_users_from_file(file_name: str):
    raw_data = get_raw_data(file_name)
    return []

def calculate_users_info(users: list[Any]):
    return {}

def save_info_to_file(info: dict):
    pass

def get_raw_data(file_name: str):
    return []
```

## Используйте содержательные имена

Очень хорошо думайте над неймингом. Функции - это глаголы. Переменные - это существительные. 
Не надо использовать однобуквенные переменные или функции, дайте им адекватное название.
Единственное место, где допускаются однобуквенные переменные - это индексы в циклах и там, где это соответствует доменной области.

## Аргументы функции

Идеальная функция не содержит аргументов. К такому можно стремиться в классах и их методах, чтобы каждый метод работал с состоянием класса.
В обычных функциях это не всегда достижимо. Для меня идеальные функции - это те, которые принимают 1-2 аргумента.

## Аргументы флаги

Если ваша функция принимает аргумент-флаг, который меняет ее поведение внутри, то это противоречит Правилу одной операции. Избегайте аргументов-флагов.
Пример:

```python
def print_amount(amount: int, is_rubles: bool = False):
    if is_rubles:
        print(f"{amount} rub")
    else:
        print(f"{amount} $")
```

Это плохая функция, она меняет свое поведение в зависимости от флага. Как ее улучшить? разбить на две функции:
```python
def print_rub_amount(amount: int):
    print(f"{amount} rub")

def print_dollar_amount(amount: int):
    print(f"{amount} $")
```

или изменить сигнатуру:

```python
def print_amount(amount: int, currency: str):
    print(f"{amount} {currency}")
```

## Избавляйтесь от побочных эффектов

Если ваша функция обещает делать что-то одно, но делает что-то другое, скрытое от пользователя - то это плохо. 

Пример:
```python
def check_password(user_name: str, password: str):
    user = find_user_by_name(user_name)
    if user is not None:
        coded_phrase = user.get_phrase_encoded_by_password()
        phrase = cryptographer.decrypt(coded_phrase, password)
        if "valid password" == phrase:
            user.session.initialize()
            return True
    
    return False
```

Имя функции говорит о том, что мы проверяем пароль, а мы, помимо этого, инициализируем пользовательскую сессию.
Если клиент, который вызвал эту функцию, тоже решит инициализировать сессию после проверки пароля, то он может получить ошибку.

Как можно исправить? разбить на несколько функций или переименновать в check_password_and_init_session(). Но это нарушает принцип одной операции.

## DRY

don't repeat yourself - если вы видите, что в вашем коде есть повторяющиеся участки, виделите его в отдельную функцию и переиспользуйте

## KISS

keep it simple, stupid - делай проще, глупышка. НЕ НАДО УСЛОЖНЯТЬ ВАШ КОД. Делайте проще, понятнее.

## YAGNI

you aren't gonna need it - вам это не понадобится. Реализуйте только то, что требуется, не наслаивайте абстракции, не придумываете себе вызовы. Решайте конкретную боль или проблему.
Когда можно наслаивать? когда вы изначально понимаете, что пишите серьезный функционал, который будет расширяться и это надо поддержать.